STL 顺序容器:顺序容器具有插入速度快但查找操作相对较慢的特征。
•std::vector:操作与动态数组一样,在最后插入数据;可将 vector 视为书架,您可在一端添加和拿走图书。
•std::deque:与 std::vector 类似,但允许在开头插入或删除元素。
•std::list:操作与双向链表一样。可将它视为链条,对象被连接在一起,您可在任何位置添加或删除对象。
•std::forward_list:类似于 std::list,但是单向链表,只能沿一个方向遍历

关联容器:这将降低插入数据的速度,但在查询方面有很大的优势。
•std::set:存储各不相同的值,在插入时进行排序;容器的复杂度为对数。
•std::unordered_set:存储各不相同的值,在插入时进行排序;容器的复杂度为常数。这种容器是 C++11 新增的。
•std::map:存储键-值对,并根据唯一的键排序;容器的复杂度为对数。
•std::unordered_map:存储键-值对,并根据唯一的键排序;容器的复杂度为对数。这种容器是C++11 新增的。
•std::multiset:与 set 类似,但允许存储多个值相同的项,即值不需要是唯一的。
•std::unordered_multiset:与 unordered_set 类似,但允许存储多个值相同的项,即值不需要是唯一的。这种容器是 C++11 新增的。
• std::multimap:与 map 类似,但不要求键是唯一的。
• std::unordered_multimap:与 unordered_map 类似,但不要求键是唯一的。这种容器是 C++11新增的。

容器适配器:容器适配器(Container Adapter)是顺序容器和关联容器的变种,其功能有限,用于满足特定的需求
•std::stack:以 LIFO(后进先出)的方式存储元素,让您能够在栈顶插入(压入)和删除(弹出)元素。
• std::queue:以 FIFO(先进先出)的方式存储元素,让您能够删除最先插入的元素。
• std::priority_queue:以特定顺序存储元素,因为优先级最高的元素总是位于队列开头。

STL 中的迭代器是模板类,从某种程度上说,它们是泛型指针。这些模板类让程序员能够对 STL容器进行操作
迭代器的分类：
输入迭代器、输出迭代器
前向迭代器、双向迭代器、随机访问迭代器

STL 算法
• std::find:在集合中查找值。
• std::find_if:根据用户指定的谓词在集合中查找值。
• std::reverse:反转集合中元素的排列顺序。
• std::remove_if:根据用户定义的谓词将元素从集合中删除。
• std::transform:使用用户定义的变换函数对容器中的元素进行变换。


迭代器是一个接口,将算法(find)连接到其要操作的数据所属的容器(如 vector)
find 操作的结果也是一个迭代器

STL 容器类的特点
std::deque(顺序容器)：具备 vector 的所有优点,还可在容器开头插入数据,插入时间也是固定的

std::forward_list(顺序容器)：单向链表类,只能沿一个方向遍历。只能使用 push_front( )在链表开头插入元素

std::unordered_set (关联容器)：由于元素未被严格排序（set排序了）,因此不能依赖于元素在容器中的相对位置

std::unordered_multiset：需要存储非唯一值，性能与 unordered_set 类似,即搜索、插入和删除元素的时间是固定的,不受容器长度的影响

std::map(关联容器)：用于存储键-值对的容器,搜索时间与元素个数的对数成反比,因此搜索速度通常比顺序容器快得多












STL 字符串类

•std::string:基于 char 的 std::basic_string 具体化,用于操纵简单字符串。
•std::wstring:基于 wchar_t 的 std::basic_string 具体化,用于操纵宽字符串,通常用于存储支持各种语言中符号的 Unicode 字符。

问:我需要一个数组,但不知道它应包含多少个元素。请问我应使用哪种 STL 容器?
答:std::vector 或 std::deque 能够很好地满足这种需求。这两种容器都负责管理内存,并可根据应用程序需求动态地调整大小。

问:我的应用程序经常需要执行搜索操作,我应选择哪种容器?
答:诸如 std::map 和 std::set 及其 unordered 变种等关联容器最适合于需要经常进行搜索的应用程序。

问:我要存储键-值对,并希望能够快速完成查找,但键可能不是唯一的。我应选择哪种容器?
答:关联容器 std::multimap 适合这种需求。multimap 可存储非唯一的键-值对,查找速度也快,这是关联容器的一个特点。

问:我要开发一个能够在不同平台和编译器之间移植的应用程序,该程序还需要使用能够根据键快速查询的容器。我应使用 std::map 还是 std::hash_map?
答:移植性是一个重要约束条件,必须使用遵循标准的容器。hash_map 不是 C++标准的一部分,因此并非所有的平台都支持它。如果您使用的是遵循 C++11 的编译器,也可使用 std::unordered_map

