使用指针运算符(->)访问成员,类指针访问

析构函数～

使用 char*缓冲区时,您必须自己管理内存分配和释放,因此本书建议不要使用它们,而使用
std::string。std::string 等工具都是类,它们充分利用了构造函数和析构函数

浅复制存在的问题
MyString 类包含一个指针成员 buffer,它指向动态分配的内存(这些内存是
在构造函数中使用 new 分配的,并在析构函数中使用 delete[]进行释放)
。复制这个类的对象时,将复
制其指针成员,但不复制指针指向的缓冲区,其结果是两个对象指向同一块动态分配的内存。销毁其
中一个对象时,delete[]释放这个内存块,导致另一个对象存储的指针拷贝无效



复制构造函数
复制构造函数接受一个以引用方式传入的当前类的对象作为参数
MyString::MyString(const MyString& copySource)
{
// Copy constructor implementation code
}

移动构造函数

不允许复制的类
禁止类对象被复制,可声明一个私有的复制构造函数。这确保函数调用
DoSomething(OurPresident)无法通过编译。为禁止赋值,可声明一个私有的赋值运算符

禁止在栈中实例化的类

关键字 explicit 声明的构造函数:禁止隐式转换

struct和class默认的访问限定符(public 和 private)不同

友元函数，友元成员函数，友元类

共用体union：与结构类似,共用体的成员默认也是公有的,但不同的是,共用体不能继承。
另外,将 sizeof()用于共用体时,结果总是为共用体最大成员的长度,即便该成员并不处
于活动状态。
换句话说，每一瞬间只有一个成员起作用，其他成员不起作用


类和结构体的聚合初始化



我的类包含一个原始指针 int*,它指向一个动态分配的 int 数组。请问将 sizeof 用于这个类的
对象时,结果是否取决于该动态数组包含的元素数




