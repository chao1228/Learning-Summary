指针是存储内存地址的变量,也占用内存空间,16进制表示。就像 int 变量用于存储整数值一样,指针变量用于存储内存地址

您不希望访问随机的内存地址,因此将指针初始化为 NULL。NULL 是一个可以检查的值,且不会是内存地址

如果 varName 是一个变量,&varName 将是存储该变量的内存的地址

变量占用的内存量取决于其类型

引用运算符(&)也叫地址运算符

使用指针存储地址

使用解除引用运算符(*)访问指向的数据。（解除引用运算符(*)也叫间接运算符）

存储地址所需的字节数是固定的。
将 sizeof( )用于指针时,结果取决于编译程序时使用的编译器和针对的操作系统,与指针指向的变量类型无关。一般1字节

new 将返回指向一个指针,指向分配的内存,否则将引发异常。
使用 new 时，需要指定要为哪种数据类型分配内存

使用 new 分配的内存最终都需使用对应的 delete 进行释放
使用 new[...]分配的内存块,需要使用 delete[]来释放

将递增和递减运算符(++和−−)用于指针的结果

调用 delete[]来释放内存时,必须指定分配内存时 new 返回的指针地址。这个值最初存储在
pointsToInts 中,但第 20 行的运算符++修改了 pointsToInts,因此第 25 行使用运算符-=让 pointsToInts
重新指向原来的地址,再在第 28 行对这个地址调用 delete[]。


将关键字 const 用于指针
	
	.指针包含的地址是常量,不能修改,但可修改指针指向的数据:
	int* const pDaysInMonth = &daysInMonth;
	.指针指向的数据为常量,不能修改,但可以修改指针包含的地址,即指针可以指向其他地方:
	const int* pointsToInt = &hoursInDay;
	int* newPointer = pointsToInt; // Not OK! Cannot assign const to non-const
	.指针包含的地址以及它指向的值都是常量,不能修改(这种组合最严格):
	const int* const pHoursInDay = &hoursInDay;
	
将指针传递给函数

数组变量就是指针
可将数组赋给指针,如第 11 行所示,但不能将指针赋给数组,因为数组是静态的,不能用作左值


如果有指针的多个拷贝,只需对其中一个调用 delete

悬浮指针：声明了但是没有赋值的指针，避免悬浮指针的方法是开始就赋值为NULL

如果不想处理异常 std::bad_alloc,可使用 new(nothrow),它在内存分配失败时返回 NULL

引用是变量的别名


引用运算符(&)

可能需要禁止通过引用修改它指向的变量的值,为此可在声明引用时使用关键字 const
使用 const 引用确保被调用的函数不能修改按引用传入的值

问:为何要按引用向函数传递值?
答:可以不这样做,只要对程序性能影响不大。然而,如果函数接受非常大的对象,则按值传递
的开销将非常大,通过使用引用,可极大地提高函数调用的效率。别忘了将 const 用于引用参数,除非
函数需要将结果存储在参数中
实参不需要复制给形参

new 和 delete 是函数吗？  
它们是运算符


下面三个重载的函数有何相同和不同之处?
int DoSomething(int num1, int num2);
int DoSomething(int& num1, int& num2);
int DoSomething(int* pNum1, int* pNum2);




