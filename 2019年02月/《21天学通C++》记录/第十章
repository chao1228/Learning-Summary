继承
class Carp:public Fish

基类初始化—向基类传递参数
Tuna(): Fish(false) {} // constructor initializes base

调用基类中被覆盖的方法
myDinner.Fish::Swim();

在派生类中调用基类的方法
使用作用域解析运算符(::)来调用基类方法

在派生类中隐藏基类的方法

构造顺序
例化 Fish 部分和 Tuna 部分时,先实例化成员属性(如 Fish::isFreshWaterFish),再调用
构造函数,确保成员属性准备就绪,可供构造函数使用

析构顺序

私有继承
私有继承意味着在派生类的实例中,基类的所有公有成员和方法都是私有的—不能从外部访问。
换句话说,即便是 Base 类的公有成员和方法,也只能被 Derived 类使用,而无法通过 Derived 实例来使用它们

保护继承
如果继承关系是私有的,而不是保护的,RaceCar 将不能访问 Motor 类的公有成员,因为编译器根据最严格的
访问限定符来确定访问权。

切除问题
要避免切除问题,不要按值传递参数,而应以指向基类的指针或 const 引用的方式传递

多继承

使用 final 禁止继承

类的继承关系默认为私有。如果 Derived 是结构,继承关系将为公有。

务必牢记,公有继承意味着继承派生类的类能
够访问基类的公有和保护成员。可通过派生类的对

务必牢记,私有继承意味着继承派生类的类也
在派生类中,不要编写与基类方法同名但参数
不同的方法,以免隐藏基类方法。不能访问基类的成员。

务必牢记,保护继承意味着继承派生类的类能
够访问基类的公有和保护方法,但不能通过派生类的对象来访问基类的公有成员。

务必牢记,无论继承关系是什么,派生类都不
能访问基类的私有成员

对于使用 new 在自由存储区中实例化的派生类对象,如果将其赋给基类指针,
并通过该指针调用 delete,将不会调用派生类的析构函数。这可能导致资源未释放、内存泄露等问题,必须引起重视。
要避免这种问题,可将析构函数声明为虚函数

务必像下面这样将基类的析构函数声明为虚函数:
class Base
{
public:
virtual ~Base() {}; // virtual destructor
};
这可避免将 delete 用于 Base 指针时,派生类实例未被妥善销毁的情况发生

虚函数表指针
基类和子类都有自己的虚函数表

纯虚函数 = 0

虚函数解决“菱形问题”

从 Base 类派生出 Derived1 和 Derived2 类时,如果使用了关键字 virtual,则意味着再从
Derived1 和 Derived2 派生出 Derived3 时,每个 Derived3 实例只包含一个 Base 实例

表明覆盖意图的限定符 override

被声明为 final 的类不能用作基类,同样,对于
被声明为 final 的虚函数,不能在派生类中进行覆盖

在派生类中声明要覆盖基类函数的函数时,务必使用关键字 override。

别忘了,在菱形继承层次结构中,虚继承旨在确保只有一个基类实例。

用于创建继承层次结构和声明基类函数时,关键字 virtual 的作用不同,请不要混为一谈

问:在继承层次结构中,需要在所有虚函数声明中都使用关键字 virtual,还是只需在基类中这样做?
答:只需在基类的函数声明中使用关键字 virtual 即可。

问:在 ABC 中,可定义成员函数和成员属性吗?
答:当然可以。这样的 ABC 也不能被实例化,因为它至少包含一个纯虚函数,派生类必须实现该函数。

编译器为每个类都创建虚函数表吗?
编译器只为包含虚函数的类创建 VFT。

class Vehicle
{
public:
Vehicle() {}
~Vehicle(){}
};
class Car: public Vehicle
{
public:
Car() {}
~Car() {}
};
给定练习 2 所示的(错误)代码,像下面这样创建并销毁 Car 实例时,将按什么样的顺序执行
构造函数和析构函数?
Vehicle* pMyRacer = new Car;
delete pMyRacer;


