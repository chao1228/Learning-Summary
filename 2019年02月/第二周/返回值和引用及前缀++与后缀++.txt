	class Age   
	{   
	public:   
	  
	    Age& operator++() //前置++   
	    {   
	        ++i;   
	        return *this;   
	    }   
	  
	    const Age operator++(int) //后置++   
    {   
	        Age tmp = *this;   
	        ++(*this);  //利用前置++   
	        return tmp;   
	    }   
	  
	    Age& operator=(int i) //赋值操作   
	    {   
	        this->i = i;   
	        return *this;   
	    }   
	  
	private:   
	    int i;   
	};  
--------------------- 
前置++的返回类型是Age&，后置++的返回类型const Age。这意味着，前置++返回的是左值，后置++返回的是右值。
	int main()   
	{   
	    Age a;   
	  
	    (a++)++;  //编译错误   
	    ++(a++);  //编译错误   
	    a++ = 1;   //编译错误   
	    (++a)++;  //OK   
	    ++(++a);  //OK   
	    ++a = 1;   //OK   
	}  
--------------------- 
a++的返回类型为什么要是const对象呢？

有两个原因：

    如果不是const对象，a(++)++这样的表达式就可以通过编译。但是，其效果却违反了我们的直觉 。a其实只增加了1，因为第二次自增作用在一个临时对象上。
    另外，对于内置类型，(i++)++这样的表达式是不能通过编译的。自定义类型的操作符重载，应该与内置类型保持行为一致 。

a++的返回类型如果改成非const对象，肯定能通过编译，但是我们最好不要这样做。

 

++a的返回类型为什么是引用呢？

这样做的原因应该就是：与内置类型的行为保持一致。前置++返回的总是被自增的对象本身。因此，++(++a)的效果就是a被自增两次
--------------------- 
形参的区别

前置++没有形参，而后置++有一个int形参，但是该形参也没有被用到。很奇怪，难道有什么特殊的用意？

其实也没有特殊的用意，只是为了绕过语法的限制。

 

前置++与后置++的操作符重载函数，函数原型必须不同。否则就违反了“重载函数必须拥有不同的函数原型”的语法规定。

虽然前置++与后置++的返回类型不同，但是返回类型不属于函数原型。为了绕过语法限制，只好给后置++增加了一个int形参。


--------------------- --------------------- --------------------- --------------------- --------------------- --------------------- 


　运算符左侧的对象就是操作对象，比如

1 ObjectA = ObjectB 等同于ObjectA.operator=（ObjectB） 
2 ObjectA+=ObjectB 等同于ObjectA.operator+（ObjectB）






当返回的值不是引用型时，编译器会专门给返回值分配出一块内存的
函数返回时，如果不是返回一个变量的引用，则一定会生成一个临时变量。
1 T function1(){
2     T t(0);
3     return t;
4 }
5 T x=function1();

这里的过程是：
1.创建命名对象t
2.拷贝构造一个无名的临时对象，并返回这个临时对象
3.由临时对象拷贝构造对象x
4.T x=function1();这句语句结束时，析构临时对象
这里一共生成了3个对象，一个命名对象t，一个临时对象作为返回值，一个命名对象x。



那么什么情况下要返回对象的引用呢？

原因有两个：

    　　允许进行连续赋值
        防止返回对象（返回对象也可以进行连续赋值（常规的情况，如a = b = c，而不是（a = b） = c））
		的时候调用拷贝构造函数和析构函数导致不必要的开销，降低赋值运算符的效率。

　　

　　对于第二点原因：如果用”值传递“的方式，虽然功能仍然正确，但由于return语句要把*this拷贝到保存返回值的外部存储单元之中，
	增加了不必要的开销，会降低赋值函数的效率。
	

	
	对此类运算符重载时，还是老老实实的返回引用，少搞事，做个好男孩：）！！！！！